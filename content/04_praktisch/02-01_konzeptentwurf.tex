\section{Konzeptentwurf}
Bevor die Anwendung in die Cloud migriert werden kann, muss konzeptioniert werden, wie die Anwendungsarchitektur in Zukunft aussehen soll und wie diese final funktionieren wird. Dazu wurde vorangehend in der Anforderungsanalyse herausgearbeitet, welche Migrationsstrategie verfolgt werden soll und welche Voraussetzungen dafür geschaffen werden müssen.

\subsection{Existierender Code}
Ziel der Anwendung ist das Einsammeln der \textit{\glspl{Timesheet}}, in dem Projekt aktiver Mitarbeiter, aus einem \gls{Box} Verzeichnis, das Überprüfen dieser und die anschließende Rechnungs- und Report Erstellung. Die Prozesse werden jeweils manuell über eine Konsoleneingabe gestartet. Im \gls{Box}-Verzeichnis liegt ein Projektmanagement-File, welcher alle Mitarbeiter enthält, die jemals in dem Projekt gearbeitet haben und markiert, welche auch aktuell aktiv sind und dem Kunden in Rechnung gestellt werden können. Außerdem sind in dem Verzeichnis auch die Reports aus einem Zeiterfassungstool abgelegt. In Abbildung \ref{fig:pmo_python} wird der Aufbau der ursprünglichen Anwendung dargestellt.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\textwidth]{pmo_python.png}
    \caption{Aufbau der ursprünglichen Anwendung (gelb umrandet der Teil, der prototypisch migriert wird)}
    \label{fig:pmo_python}
\end{figure}

Die bisher existierende Anwendung ist eine Python Anwendung, die grundsätzlich in dre Module aufgeteilt ist:
\begin{itemize}
\item \textbf{Timesheet Collector: }Einsammeln der \textit{\glspl{Timesheet}}, der in dem Projekt aktiven Mitarbeiter
\item \textbf{Timesheet Checker: }Überprüfen der \textit{\glspl{Timesheet}} auf Korrektheit und Vollständigkeit und gegebenenfalls Reparatur dieser
\item \textbf{Report Creator: }Erzeugung eines Reports, Zusammenfassung der \textit{reporteten} Stunden und Verteilung dieser auf die unterschiedlichen Beauftragungen, Erstellung von Nachweisdokumenten und automatisierte Rechnungsstellung
\end{itemize}

Jeder dieser drei Services ist ein eigenes Python Modul. Diese greifen jeweils auf weitere Services wie einen Excel-Helper und Checking-Tools zurück.

Da es sich bei dieser Arbeit um eine Machbarkeitsstudie mit Erstellung eines Prototypen handelt, wird im ersten Schritt nur die Migration des Collect Service untersucht, bevor die anderen, komplexeren Services migriert werden. Dies ist in Abbildung \ref{fig:pmo_python} entsprechend durch den gelben Rahmen gekennzeichnet. Der Collect Service benötigt eine Verbindung zu dem \gls{Box}-Verzeichnis und einen Ablageort für die \glqq{eingesammelten}\grqq{} \textit{\glspl{Timesheet}}.

\subsection{Placeholder}
Da die ursprüngliche Anwendung einige Funktionalitäten auf eine Weise umsetzt, die nicht in der Cloud funktionieren würde (z.B. das Lesen und Schreiben in Box), müssen diese überarbeitet oder neu geschrieben werden. Ein simples Rehosting ist durch die anfallenden Anpassungen entsprechend nicht möglich.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{architektur.png}
    \caption{Grober Architekturentwurf}
    \label{fig:Architektur}
\end{figure}

Abbildung \ref{fig:Architektur} zeigt einen groben  Entwurf der Anwendung und wie die Services miteinander kommunizieren sollen. Der \textit{\gls{Timesheet}}Service soll zu einem späteren Zeitpunkt alle Funktionen aus der Ursprünglichen Anwendung bündeln, für den Prototypen wird sich jedoch, wie bereits in der Anforderungsanalyse erwähnt, auf den Collect Service beschränkt.

\subsection{Konzeptionierung der Services}
In der ursprünglichen Anwendung ist der Zugriff auf die \gls{Box} mithilfe der Box Drive Erweiterung umgesetzt worden. Diese ermöglicht es, Verzeichnisse in der \gls{Box} wie einen lokalen Dateipfad ansprechen zu können, zum Beispiel \textit{C:/Users/User/Box/Folder}. Somit konnte der Box-Pfad in eine Konfigurationsdatei geschrieben und als Parameter an die Anwendung übergeben werden. Nachteil an dieser Umsetzung ist die Notwendigkeit den \gls{Box}-Pfad anpassen zu müssen, wenn ein anderer Nutzer die Anwendung startet. Eine Einbindung der \gls{Box} \ac{API} für den Prototypen wird aus diesem Grund unumgänglich sein.

Der \gls{Box} Service muss Dateien herunterladen, die Inhalte von Ordnern auflisten und Ordner IDs ermitteln können.

Außerdem enthalten die PMO-Tools ein \glqq{excelhelper.py}\grqq{} Skript, welches den Umgang mit Excel Spreadsheets ermöglicht. Dazu gehört zum einen das Ermitteln aktiver Mitarbeiter und zum anderen das Auslesen der \textit{\glspl{Timesheet}}, was jedoch für den Prototypen keine Verwendung findet. Einen vergleichbaren Service muss auch die neue Anwendung enthalten. Für Java kann man in diesem Fall auf die Apache POI Programmbibliothek zurückgreifen, welche das Lesen und Schreiben von Microsoft Office Dateien ermöglicht.

Den \glqq{Hauptservice}\grqq{} der Anwendung soll der \textit{\gls{Timesheet}}Service bilden. Dieser soll alle Funktionen bereitstellen, die unter Verwendung der anderen Services die letztendlich gewünschte Funktionalität des Einsammeln der \textit{\glspl{Timesheet}} bieten. Darüber hinaus soll dieser für eine Spätere Anwendungsversion auch die anderen Funktionalitäten aus der ursprünglichen Anwendung bereitstellen. Dieser Service soll zu einem Späteren Zeitpunkt immer dann getriggert werden, wenn eine neue Konfigurationsdatei in einen entsprechenden \gls{Box} Ordner geladen wird. Für den Prototypen reicht jedoch ein simpler Trigger oder der Start via \ac{API} \textit{Request} aus. \textbf{TODO: Rephrasing und detaillierte Beschreibung der Architektur (welche Dienste werden benötigt)}\pagebreak

\subsection{Programmiersprache und Framework}
Neben der Konzeptionierung einer Anwendungsarchitektur braucht es zur Entwicklung auch eine Programmiersprache und gegebenenfalls ein Framework, um die Anwendung optimal in der Cloud nutzen zu können. 

Im Falle der PMO-Tools wurde ursprünglich Python verwendet, jedoch erschien im Zuge des Refactoring ein Wechsel zu Java und dem \gls{Spring} Framework sinnvoll, da hier mit \gls{Spring Boot} die Cloud native Entwicklung erleichtert wird. Darüber hinaus gilt \gls{Spring Boot} als populärer Standard für Microservices.

\subsection{Auswahl eines Cloud Providers}
Ein für die Cloud Migration unerlässlicher Schritt ist die Auswahl eines zu den Anforderungen passenden Cloud Providers. In diesem Fall wurde \ac{AWS} als einer der größten Provider gewählt, da hier mit \ac{ECS} und Fargate gute Cloud native Möglichkeiten zum serverless Deployment von Containern zur Verfügung stehen um somit die Vorteile der Cloud optimal nutzen zu können. Darüber hinaus unterstützt \ac{AWS} viele offene Standards, wie zum Beispiel Terraform.

Alternativ wurden auch die Services der IBM-Cloud in Betracht gezogen, da hier mit \textit{Cloud Functions} oder \textit{Terraform} ebenfalls Plattformen zum Deployment von Containern existieren, die jedoch zum einen schwieriger aufzusetzen schienen und zum anderen bezüglich Administration und Einfachheit der Bedienung nicht mit \ac{ECS} vergleichbar sind. Ebenfalls hätte Azure, die Cloud Plattform von Microsoft infrage kommen können, da jedoch \ac{AWS} auch im Projektumfeld eingesetzt wird, wurde diese Alternative bevorzugt. \pagebreak